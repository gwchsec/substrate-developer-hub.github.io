---
title: "Module Struct"
---

The `Module` struct is the backbone of all Substrate runtime modules. It is used to connect together the various components included in your module. The `Module` struct is generated by the [`decl_module!` macro](runtime/macros/decl_module.md) and exists for every runtime module.

This page will explore the various components of the `Module` struct to help gain a better understanding of how it all works together.

## Components of the Module Struct

The base definition of the module struct is empty:

```rust
pub struct Module<T: Trait>();
```

However, on top of this struct, we implement all of our module's traits:

* [Callable](#callable)
* [Store](#store)
* [OnInitialize / OnFinalize](#oninitalize-onfinalize)
* OffchainWorker
* etc...

In addition, the `Module` struct is used to [implement all of the various runtime functions](#function-implementations) like `deposit_event` and any dispatchable functions you define.

## Module Struct Implementations

### Callable

The `Callable` trait for the `Module` struct defines how a module can be called via an extrinsic. `Callable` implements trait the module's `Call` enum that handles function dispatch. All dispatchable functions will be exposed through this `Call` enum, which you can learn more about [here](runtime/types/call-enum.md).

```rust
impl<T: Trait> Callable for Module<T> {
    type Call = Call<T>;
}
```

### Store

The `Store` trait lists all of the runtime storage items exposed by the module. Each storage item is given a struct onto which all of its storage APIs are defined. You can learn more about individual storage items [here](https://stackoverflow.com/questions/56599293/what-is-the-purpose-of-pub-in-decl-storage).

<!-- TODO: Create dedicated documentation for individual storage items and update link above. -->

### OnInitialize / OnFinalize

The `OnInitialize` and `OnFinalize` trait are used to implement the `on_intialize` and `on_finalize` functions that contain any logic which should be run at the beginning or end of runtime execution. You can learn more about those functions [here](runtime/macros/decl_module.md#on_initialise-and-on_finalise).

### Function Implementations

The `Module` struct is also used to implement all the various module functions we define, including those defined in `decl_module!`.

This is why, when writing internal module functions, you do so in `impl<T: Trait> Module<T> { ... } `. We then gain access to these functions throughout our module with `Self::function_name()`.

For example, the default definition of `deposit_event` expands to look like:

```rust
impl <T: Trait> Module<T> {
    fn deposit_event(event: Event<T>) {
        <system::Module<T>>::deposit_event(<T as Trait>::from(event).into());
    }
}
```

and can be accessed with:

```rust
Self::deposit_event(...)
```

## All Modules Tuple

The `Module` struct is finally imported into your overall blockchain's runtime using the `construct_runtime!` macro. This macro includes your module along with all the other modules into a tuple called `AllModules`:

```
type AllModules = (timestamp::Module<Runtime>, balances::Module<Runtime>, template::Module<Runtime>, ...);
```

This tuple is used by the runtime's [Executive module](https://substrate.dev/rustdocs/master/srml_executive/index.html) which handles orchestration of executing these modules.

## Module Metadata

Just like the `Module` struct, the metadata for your module contains all the various components of your module such as its storage items, callable funcitons, and events. When represented as JSON, the metadata for a module will look like:

```json
{
    "modules":[
        {
            "name":"template",
            "prefix":"TemplateModule",
            "storage":[...],
            "calls":[...],
            "events":[...]
        }
    ]
}
```
